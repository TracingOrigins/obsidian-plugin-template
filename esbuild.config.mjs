import esbuild from "esbuild";
import process from "node:process";
import { builtinModules } from 'node:module';
import fs from "node:fs";
import path from "node:path";

// ==================== 常量定义 ====================

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === "production");
const outDir = "dist";

// 路径常量
const cssRoot = path.join(process.cwd(), 'src');
const cssDest = path.join(process.cwd(), outDir, 'styles.css');

// ==================== 工具函数 ====================
// 递归收集 src 下的所有 CSS 文件
function collectCssFiles(dir) {
	const results = [];
	if (!fs.existsSync(dir)) return results;
	const entries = fs.readdirSync(dir, { withFileTypes: true });
	for (const entry of entries) {
		const full = path.join(dir, entry.name);
		if (entry.isDirectory()) {
			results.push(...collectCssFiles(full));
		} else if (entry.isFile() && entry.name.endsWith('.css')) {
			results.push(full);
		}
	}
	return results;
}

// ==================== 主要功能函数 ====================
// 构建 CSS：将 src 下的所有 CSS 文件合并输出到 dist/styles.css
// - 开发模式：合并并保留注释，便于阅读和调试
// - 生产模式：通过 esbuild 压缩并移除注释，生成精简版 CSS
async function buildCSS() {
	if (!fs.existsSync(cssRoot)) {
		console.warn('⚠ CSS 根目录不存在: src');
		return;
	}

	const cssFiles = collectCssFiles(cssRoot).sort();
	if (!cssFiles.length) {
		// 如果没有任何 CSS 文件，删除 dist 中已存在的 styles.css（如果存在）
		if (fs.existsSync(cssDest)) {
			fs.unlinkSync(cssDest);
			console.log('✓ 已删除 dist/styles.css（源目录中没有 CSS 文件）');
		}
		return;
	}

	const parts = cssFiles.map((file) => {
		const rel = path.relative(process.cwd(), file);
		const content = fs.readFileSync(file, 'utf8');
		return `/* ${rel} */\n${content}`;
	});
	const combinedCss = parts.join('\n\n');

	try {
		// 确保输出目录存在
		fs.mkdirSync(path.join(process.cwd(), outDir), { recursive: true });

		// 使用 esbuild 转换 CSS
		// - 生产模式：压缩并移除注释
		// - 开发模式：不压缩，仅做语法校验
		const result = await esbuild.transform(combinedCss, {
			loader: 'css',
			minify: prod,
			sourcemap: false,
		});

		fs.writeFileSync(cssDest, result.code);
	} catch (error) {
		// 如果转换失败，回退到未压缩版本
		console.error('构建 CSS 时出错，已回退到未压缩版本:', error);
		fs.writeFileSync(cssDest, combinedCss);
	}

	console.log(`✓ CSS 已打包: ${cssDest}（共 ${cssFiles.length} 个文件）`);
}

// 复制 manifest.json 到输出目录
function copyManifest() {
	const src = path.join(process.cwd(), 'manifest.json');
	const dest = path.join(process.cwd(), outDir, 'manifest.json');
	
	try {
		// 确保输出目录存在
		fs.mkdirSync(path.join(process.cwd(), outDir), { recursive: true });
		fs.copyFileSync(src, dest);
	} catch (e) {
		console.error('⚠ 复制 manifest.json 失败:', e.message);
	}
}

// ==================== 监听函数 ====================
// 监听 manifest.json 变化（带防抖和内容比较）
function watchManifest() {
	const manifestPath = path.join(process.cwd(), 'manifest.json');
	
	if (!fs.existsSync(manifestPath)) {
		return;
	}

	let copyTimer = null;
	let lastContent = fs.readFileSync(manifestPath, 'utf8');
	
	fs.watch(manifestPath, () => {
		// 防抖：延迟 100ms 执行
		if (copyTimer) {
			clearTimeout(copyTimer);
		}
		copyTimer = setTimeout(() => {
			try {
				const newContent = fs.readFileSync(manifestPath, 'utf8');
				// 只有内容真正改变时才复制
				if (newContent !== lastContent) {
					lastContent = newContent;
					copyManifest();
				}
			} catch (e) {
				console.error('⚠ 读取 manifest.json 失败:', e.message);
			}
			copyTimer = null;
		}, 100);
	});
}

// 监听 CSS 文件变化
function watchCSS() {
	if (!fs.existsSync(cssRoot)) {
		return;
	}

	let buildTimer = null;
	fs.watch(cssRoot, { recursive: true }, (eventType, filename) => {
		// 只处理 CSS 文件的变化
		if (filename && filename.endsWith('.css')) {
			// 防抖：延迟 100ms 执行
			if (buildTimer) {
				clearTimeout(buildTimer);
			}
			buildTimer = setTimeout(() => {
				void buildCSS();
				buildTimer = null;
			}, 100);
		}
	});
}

// 创建 esbuild context
const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ["src/main.ts"],
	bundle: true,
	loader: {
		'.ts': 'ts',
		'.tsx': 'tsx',
		'.json': 'json',
		'.css': 'empty', // 忽略 CSS 导入，使用自定义的 buildCSS 函数生成 styles.css
	},
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtinModules],
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outdir: "dist",
	minify: prod,
});

// ==================== 主执行逻辑 ====================
async function main() {
	// 初始构建：CSS 和 manifest.json
	await buildCSS();
	copyManifest();

	if (prod) {
		// 生产模式：构建并退出
		await context.rebuild();
		process.exit(0);
	} else {
		// 开发模式：启动监听
		watchManifest();
		watchCSS();
		await context.watch();
	}
}

// 执行主函数
main().catch((error) => {
	console.error('构建失败:', error);
	process.exit(1);
});
